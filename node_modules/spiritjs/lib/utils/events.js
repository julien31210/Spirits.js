'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.bubbleEvent = bubbleEvent;
exports.createEventObjectForModel = createEventObjectForModel;
exports.clearEvents = clearEvents;

var _events = require('events');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Bubble events.
 *
 * @param   {string}  evt
 * @param   {*}       scope event emitter
 * @returns {function}
 */
function bubbleEvent(evt, scope) {
  if (!(scope instanceof _events.EventEmitter)) {
    throw new Error('Scope needs to be an event emitter.');
  }

  return function () {
    this.emit.apply(this, [evt].concat(Array.prototype.slice.call(arguments)));
  }.bind(scope);
}

/**
 * Create an event object for model.
 *
 * @param   {*}       model model class
 * @param   {*}       obj model instance
 * @param   {string}  prop change property
 * @param   {*}       prevVal the previous value
 * @param   {*}       nextVal the next value
 * @returns {Object}  event object.
 */
function createEventObjectForModel(model, obj, prop, prevVal, nextVal) {
  /**
   * Event object.
   *
   * @type {object}
   * @property {object} prevModel - param before change
   * @property {object} model - param after change
   * @property {object} changed - {type, from, to}
   */
  var evt = {
    prevModel: model.fromObject(obj),
    model: model.fromObject(_extends({}, obj, _defineProperty({}, prop, nextVal))),
    changed: {
      type: prop,
      from: prevVal,
      to: nextVal
    }
  };

  return evt;
}

/**
 * Clean up events.
 *
 * @param {*}     emitter
 * @param {Array} events fallback for older node implementations
 */
function clearEvents(emitter) {
  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (emitter.eventNames && typeof emitter.eventNames === 'function') {
    emitter.eventNames().forEach(function (e) {
      return emitter.removeAllListeners(e);
    });
  } else {
    events.forEach(function (e) {
      return emitter.removeAllListeners(e);
    });
  }
}
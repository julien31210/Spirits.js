'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _transitions = require('./transitions');

var _transitions2 = _interopRequireDefault(_transitions);

var _utils = require('../utils');

var _evalmap = require('./evalmap');

var _evalmap2 = _interopRequireDefault(_evalmap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Timeline.
 */
var Timeline = function () {

  /**
   * Create new Timeline instance
   *
   * @param {string} type default = dom
   * @param {HTMLElement|Object} transformObject
   * @param {Array|Transitions} transitions
   * @param {string|null} path
   * @param {string|null} id
   * @param {string|null} label
   */


  /**
   * Identifier to select element. Override the path for resolving transformObject.
   * By default the id is set on element attribute [data-spirit-id].
   *
   * @type {string|null}
   */


  /**
   * Defined label representing this timeline node.
   *
   * @type {string|null}
   */


  /**
   * Timeline type.
   * Can be "dom" or "object"
   *
   * @type {string}
   */
  function Timeline() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'dom';
    var transformObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var transitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _transitions2.default();
    var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var label = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    _classCallCheck(this, Timeline);

    this.type = 'dom';
    this.transformObject = null;
    this.label = null;
    this.path = null;
    this.id = null;
    this.transitions = null;

    if (!(transitions instanceof _transitions2.default)) {
      transitions = new _transitions2.default(transitions);
    }

    Object.assign(this, {
      type: type,
      transformObject: transformObject,
      transitions: transitions,
      label: label,
      path: path,
      id: id
    });

    if (type === 'dom') {
      if (!transformObject || _utils.context.isBrowser() && !(transformObject instanceof window.Element)) {
        throw new Error('transformObject needs to be an element.');
      }

      if (!id && !path) {
        throw new Error('path is not defined');
      }
    }

    if (type === 'object') {
      if (!transformObject) {
        throw new Error('transformObject needs to be an object');
      }
    }

    this.transitions.mappings = [new _evalmap2.default(/this/g, transformObject)];
  }

  /**
   * Transitions for this timeline.
   *
   * @type {Transitions}
   */


  /**
   * XPath of element, normalized by group element.
   * Only relevant if type is "dom"
   *
   * @type {string|null}
   */


  /**
   * Object to apply transforms on.
   * If type is "dom" it refers to a HTMLElement else a plain javascript object
   *
   * @type {HTMLElement|Object}
   */


  _createClass(Timeline, [{
    key: 'toObject',
    value: function toObject() {
      var obj = {
        type: this.type,
        transformObject: this.transformObject,
        transitions: this.transitions.toArray(),
        label: this.label,
        path: this.path,
        id: this.id
      };

      Object.keys(obj).forEach(function (key) {
        if (!obj[key]) {
          delete obj[key];
        }
      });

      return obj;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.transitions.each(function (tr) {
        return tr.destroy();
      });
    }
  }]);

  return Timeline;
}();

Timeline.fromObject = function (obj) {
  if (!_utils.is.isObject(obj)) {
    throw new Error('Object is invalid.');
  }

  var keys = Object.keys(obj);

  if (!keys.includes('transformObject')) {
    throw new Error('Object is invalid');
  }

  var args = _utils.convert.objectToArray(obj).filter(function (arg) {
    return arg !== undefined;
  });
  args = _extends({
    type: args.type || 'dom',
    transitions: []
  }, _utils.convert.arrayToObject(args));

  return new Timeline(args.type, args.transformObject, args.transitions, args.path || undefined, args.id || undefined, args.label || undefined);
};

exports.default = Timeline;
module.exports = exports['default'];
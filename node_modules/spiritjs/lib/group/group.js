'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.groupDefaults = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _config = require('../config/config');

var _config2 = _interopRequireDefault(_config);

var _utils = require('../utils');

var _timelines = require('./timelines');

var _timelines2 = _interopRequireDefault(_timelines);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Group defaults
 *
 * @type {object}
 */
var groupDefaults = exports.groupDefaults = {
  name: undefined,
  fps: 30,
  timelines: new _timelines2.default()
};

/**
 * Group.
 */

var Group = function (_EventEmitter) {
  _inherits(Group, _EventEmitter);

  /**
   * Create a group instance.
   *
   * @param {object} props
   */
  function Group() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Group);

    var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this));

    _this._name = groupDefaults.name;
    _this._fps = groupDefaults.fps;
    _this._timelines = groupDefaults.timelines;
    _this.timeline = null;

    _this.setMaxListeners(Infinity);

    if (!props.name || typeof props.name !== 'string' || props.name.trim() === '') {
      throw new Error('Cannot create group without a name.');
    }

    Object.assign(_this, _extends({}, groupDefaults, props));
    return _this;
  }

  /**
   * Get timelines
   *
   * @returns {Timelines}
   */


  /**
   * Gsap timeline
   * @type {null|TimelineLite|TimelineMax}
   */


  _createClass(Group, [{
    key: 'toObject',


    /**
     * Convert group to object
     *
     * @returns {object}
     */
    value: function toObject() {
      var fps = this.fps;
      var name = this.name;
      var timelines = this.timelines.toArray();

      return {
        fps: fps,
        name: name,
        timelines: timelines
      };
    }

    /**
     * Construct gsap timeline
     *
     * @returns {TimelineMax|TimelineLite}
     */

  }, {
    key: 'construct',
    value: function construct() {
      var _this2 = this;

      try {
        if (!_config2.default.gsap.timeline || !_config2.default.gsap.tween) {
          if (_utils.debug) {
            console.warn('\n            Trying to construct group ' + this.name + ', but GSAP cannot be found.\n            \n            Did you forgot to call spirit.setup() ?\n            \n            spirit.setup() usage:\n            \n                // auto inject gsap from cdn:\n                spirit.setup()\n                \n                // or provide gsap instances manually:\n                spirit.setup({\n                  tween:    TweenMax,\n                  timeline: TimelineMax\n                })\n          ');
          }
          throw new Error('GSAP cannot be found');
        }

        // initiate an empty gsap timeline
        if (this.timeline && this.timeline instanceof _config2.default.gsap.timeline) {
          this.timeline.stop();
          this.timeline.kill();
          this.timeline.clear();
        } else {
          this.timeline = new _config2.default.gsap.timeline({ // eslint-disable-line new-cap
            useFrames: true,
            paused: true
          });
          this.timeline.autoRemoveChildren = false;
        }

        // create a valid gsap timeline out of timelines
        this.timelines.list.filter(function (tl) {
          return tl.type === 'dom';
        }).forEach(function (tl) {
          var el = tl.transformObject;

          if (!(el instanceof window.Element)) {
            throw new Error('transformObject is not an Element');
          }

          // kill existing tweens
          _config2.default.gsap.tween.killTweensOf(el);
          delete el._gsTransform;
          delete el._gsTweenID;
          el.setAttribute('style', '');

          // stack timelines to group timeline
          _this2.timeline.add(_utils.gsap.generateTimeline(tl).play(), 0);
        });

        // update timescale based on fps
        this.timeline.timeScale(this.fps / 60);
      } catch (err) {
        throw new Error('Could not construct timeline: ' + err.message);
      }
      return this.timeline;
    }
  }, {
    key: 'timelines',
    get: function get() {
      return this._timelines;
    }

    /**
     * Set timelines
     *
     * @param {Timelines} timelines
     */
    ,
    set: function set(timelines) {
      if (!(timelines instanceof _timelines2.default)) {
        timelines = new _timelines2.default(Array.from(timelines));
      }
      this._timelines = timelines;
    }

    /**
     * Get current fps
     *
     * @returns {number}
     */

  }, {
    key: 'fps',
    get: function get() {
      return this._fps;
    }

    /**
     * Set fps
     *
     * @param {number} fps
     */
    ,
    set: function set(fps) {
      if (!(typeof fps === 'number' && isFinite(fps))) {
        throw new Error('Fps needs to be a number');
      }
      this._fps = fps;

      if (this.timeline && this.timeline instanceof _config2.default.gsap.timeline) {
        this.timeline.timeScale(fps / 60);
      }
    }

    /**
     * Get name
     *
     * @returns {string}
     */

  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }

    /**
     * Set name
     *
     * @param {string} name
     */
    ,
    set: function set(name) {
      if (typeof name !== 'string') {
        throw new Error('Name needs to be a string');
      }
      this._name = name;
    }
  }]);

  return Group;
}(_events.EventEmitter);

Group.fromObject = function (obj) {
  return new Group(obj);
};

exports.default = Group;